[
    {
        "id": 3,
        "title": "Riding the Waves of Building a Business Management Software",
        "summary": "Starting something from scratch is always an adventurous challenge. As the challenge unfolds, the adventure lies in the pivots, decisions, and the constant refining of one's approach.",
        "body": "<article><p>Starting something from scratch is always an adventurous challenge. As the challenge unfolds, the adventure lies in the pivots, decisions, and the constant refining of one's approach. It's this same journey that led me down the road of developing a business management software for auto detailing businesses. And oh, what a ride it's been!</p><h3>Setting the Scope with an MVP</h3><p>It began a year ago when I envisioned a system to streamline the inefficiencies I noticed while working at a car detailing shop. It wasn't my first entrepreneurial adventure, so I knew I wanted more than just buzzwords and theoretical perfection. I needed something tangible, functional, and effective.</p><p>Originally, this was just supposed to be a portfolio project for my cousin Damon, whom I was mentoring in his journey into UX design. But the moment I saw the sheer quality and potential of his designs, I knew we were onto something bigger.</p><p>We dove headfirst into it. The initial goal was clear: create a Minimum Viable Product (MVP). This MVP would serve as our litmus test, helping us gauge the viability of our business model. If things looked good, we'd scale and implement the other features waiting in the wings.</p><h3>Pivoting the Tech Stack</h3><p>To bring this MVP to life, I looped in my brother, a skilled software engineer. We began with a PHP and Livewire combination. However, we hit a snag integrating Stripe and other essential libraries. As we pondered our next move, I realized that I wanted this project to be a learning avenue for juniors I trained. Tools like Laravel didn't seem enticing, so a pivot was in order.</p><p>Having some familiarity with React and Go, these became our tools of choice. Yet, the initial backend felt more like a Laravel app than a Go one. Confusing, right? That's when I decided a fresh start was necessary. This fresh start also birthed my obsession with software architecture, prompting me to devour Robert Martin's \"Clean Architecture.\"</p><h3>The Great Microservices Debate</h3><p>Around this time, my friend Dan and I found ourselves amidst heated debates. Microservices were all the rage, but were they right for our project? As an engineer, I can be incredibly stubborn. However, I pride myself on being open to change, especially when convincingly argued. And that's just what Dan did. With quotes like \"Handle complexity, see simplicity\" and Einstein's classic \"Everything should be made as simple as possible, but no simpler,\" we pondered our direction.</p><p>I realized I wasn't chasing the microservices hype but was keen on a clear separation of concerns. After evaluating our needs and potential market size, it became evident that a monolithic approach was more suitable. Still, I yearned for modularity and domain-driven design, leading to our unique service-oriented monolithic structure.</p><h3>Implementing the Structure</h3><p>For those interested in the nitty-gritty, here's a glimpse into the backend structure we crafted:</p><ul style='list-style-type:none;'><li>. (root)</li><li>├── Dockerfile</li><li>├── cmd</li><ul style='list-style-type:none;'><li>└── app</li><ul style='list-style-type:none;'><li>├── main.go</li><li>└── ...</li></ul></ul><li>├── config</li><ul style='list-style-type:none;'><li>├── AppConfig.go</li><li>├── AuthConfig.go</li><li>└── ...</li></ul><li>├── contracts</li><ul style='list-style-type:none;'><li>├── app</li><ul style='list-style-type:none;'><li>├── interfaces.go</li><li>├── types.go</li><li>└── ...</li></ul><li>└── ...</li></ul><li>├── internal</li><ul style='list-style-type:none;'><li>├── app</li><ul style='list-style-type:none;'><li>├── app.go</li><li>└── ...</li></ul></ul><ul style='list-style-type:none;'><li>├── app</li><ul style='list-style-type:none;'><li>├── app.go</li><li>└── ...</li></ul><li>└── ...</li></ul><li>├── models</li><ul style='list-style-type:none;'><li>├── Booking.go</li><li>├── Payment.go</li><li>└── ...</li></ul><li>└── utils</li><ul style='list-style-type:none;'><li>└── json.go</li></ul><p>Every route and handler found its place, and I decided to lay everything out with Get requests initially. This allowed me to focus on refining the frontend, ensuring smooth interaction with the backend. The foundation was now set, with only the database and core logic implementation pending.</p><h3>Learning and Implementing CICD</h3><p>This project was also my foray into the realms of CI/CD. True to form, I plunged into the deep end, exploring tools and technologies far and wide. Kubernetes, Docker, cloud services – you name it. Yet, in the end, I realized simplicity often trumps complexity. A straightforward VM from Digital Ocean coupled with Docker Compose and GitHub actions hit the sweet spot. For the first time in years, I witnessed the magic of end-to-end project creation. The thrill of seeing live changes in mere minutes was nothing short of exhilarating.</p><h3>Reflecting on the Journey</h3><p>Looking back, this journey has been filled with learning curves, debates, decisions, and endless refining. There were challenges aplenty, from managing a distributed team with varying commitments to grappling with architectural dilemmas. But the fruits of this labor are evident. I now see applications in a clearer light, with renewed confidence and a deeper understanding of the intricacies involved.</p><p>In the end, isn't that what journeys are all about? Growth, learning, and pushing forward, one wave at a time.</p></article>",
        "created_at": "2023-09-25T20:15:00Z"
    }
]

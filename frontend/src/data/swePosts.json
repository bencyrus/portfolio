[
    {
        "id": 1,
        "title": "Riding the Waves of Building a Business Management Software",
        "summary": "Starting something from scratch is always an adventurous challenge. As the challenge unfolds, the adventure lies in the pivots, decisions, and the constant refining of one's approach.",
        "body": "<article><p>Starting something from scratch is always an adventurous challenge. As the challenge unfolds, the adventure lies in the pivots, decisions, and the constant refining of one's approach. It's this same journey that led me down the road of developing a business management software for auto detailing businesses. And oh, what a ride it's been!</p><h3>Setting the Scope with an MVP</h3><p>It began a year ago when I envisioned a system to streamline the inefficiencies I noticed while working at a car detailing shop. It wasn't my first entrepreneurial adventure, so I knew I wanted more than just buzzwords and theoretical perfection. I needed something tangible, functional, and effective.</p><p>Originally, this was just supposed to be a portfolio project for my cousin Damon, whom I was mentoring in his journey into UX design. But the moment I saw the sheer quality and potential of his designs, I knew we were onto something bigger.</p><p>We dove headfirst into it. The initial goal was clear: create a Minimum Viable Product (MVP). This MVP would serve as our litmus test, helping us gauge the viability of our business model. If things looked good, we'd scale and implement the other features waiting in the wings.</p><h3>Pivoting the Tech Stack</h3><p>To bring this MVP to life, I looped in my brother, a skilled software engineer. We began with a PHP and Livewire combination. However, we hit a snag integrating Stripe and other essential libraries. As we pondered our next move, I realized that I wanted this project to be a learning avenue for juniors I trained. Tools like Laravel didn't seem enticing, so a pivot was in order.</p><p>Having some familiarity with React and Go, these became our tools of choice. Yet, the initial backend felt more like a Laravel app than a Go one. Confusing, right? That's when I decided a fresh start was necessary. This fresh start also birthed my obsession with software architecture, prompting me to devour Robert Martin's \"Clean Architecture.\"</p><h3>The Great Microservices Debate</h3><p>Around this time, my friend Dan and I found ourselves amidst heated debates. Microservices were all the rage, but were they right for our project? As an engineer, I can be incredibly stubborn. However, I pride myself on being open to change, especially when convincingly argued. And that's just what Dan did. With quotes like \"Handle complexity, see simplicity\" and Einstein's classic \"Everything should be made as simple as possible, but no simpler,\" we pondered our direction.</p><p>I realized I wasn't chasing the microservices hype but was keen on a clear separation of concerns. After evaluating our needs and potential market size, it became evident that a monolithic approach was more suitable. Still, I yearned for modularity and domain-driven design, leading to our unique service-oriented monolithic structure.</p><h3>Implementing the Structure</h3><p>For those interested in the nitty-gritty, here's a glimpse into the backend structure we crafted:</p><ul style='list-style-type:none;'><li>. (root)</li><li>├── Dockerfile</li><li>├── cmd</li><ul style='list-style-type:none;'><li>└── app</li><ul style='list-style-type:none;'><li>├── main.go</li><li>└── ...</li></ul></ul><li>├── config</li><ul style='list-style-type:none;'><li>├── AppConfig.go</li><li>├── AuthConfig.go</li><li>└── ...</li></ul><li>├── contracts</li><ul style='list-style-type:none;'><li>├── app</li><ul style='list-style-type:none;'><li>├── interfaces.go</li><li>├── types.go</li><li>└── ...</li></ul><li>└── ...</li></ul><li>├── internal</li><ul style='list-style-type:none;'><li>├── app</li><ul style='list-style-type:none;'><li>├── app.go</li><li>└── ...</li></ul></ul><ul style='list-style-type:none;'><li>├── app</li><ul style='list-style-type:none;'><li>├── app.go</li><li>└── ...</li></ul><li>└── ...</li></ul><li>├── models</li><ul style='list-style-type:none;'><li>├── Booking.go</li><li>├── Payment.go</li><li>└── ...</li></ul><li>└── utils</li><ul style='list-style-type:none;'><li>└── json.go</li></ul><p>Every route and handler found its place, and I decided to lay everything out with Get requests initially. This allowed me to focus on refining the frontend, ensuring smooth interaction with the backend. The foundation was now set, with only the database and core logic implementation pending.</p><h3>Learning and Implementing CICD</h3><p>This project was also my foray into the realms of CI/CD. True to form, I plunged into the deep end, exploring tools and technologies far and wide. Kubernetes, Docker, cloud services – you name it. Yet, in the end, I realized simplicity often trumps complexity. A straightforward VM from Digital Ocean coupled with Docker Compose and GitHub actions hit the sweet spot. For the first time in years, I witnessed the magic of end-to-end project creation. The thrill of seeing live changes in mere minutes was nothing short of exhilarating.</p><h3>Reflecting on the Journey</h3><p>Looking back, this journey has been filled with learning curves, debates, decisions, and endless refining. There were challenges aplenty, from managing a distributed team with varying commitments to grappling with architectural dilemmas. But the fruits of this labor are evident. I now see applications in a clearer light, with renewed confidence and a deeper understanding of the intricacies involved.</p><p>In the end, isn't that what journeys are all about? Growth, learning, and pushing forward, one wave at a time.</p></article>",
        "created_at": "2023-09-25T20:15:00Z"
    },
    {
        "id": 2,
        "title": "Navigating Software Development with Specification Documents: Lessons from JayPlus",
        "summary": "A deep dive into the transformative power of specification documents in guiding software development, drawing insights from the JayPlus journey.",
        "body": "<article><p>When I began the overhaul of JayPlus, I was crystal clear on my vision. I diligently penned down a comprehensive specification document that meticulously listed the required routes, frontend components, and everything in between. It seemed straightforward: with such detailed specs, execution should be a breeze, right? Reality had other plans.</p><h3>The Dual Nature of Specification Documents:</h3><ul><li style='margin-bottom: 15px;'>The Good: Specification documents are an invaluable asset. They force you to encapsulate the entirety of your system. At times, they act as a foolproof blueprint, guiding you to build exactly what you've envisioned.</li><li style='margin-bottom: 15px;'>The Twist: However, there are instances when these documents merely act as a stepping stone. If you're charting unfamiliar waters - for instance, trying out new tools or techniques - like my dive into creating a service-oriented monolithic application in Golang, you might veer off from your initial specifications. This is even truer when starting a project entirely from scratch, which was the scenario with JayPlus.</li></ul><h3>The Evolution of Software and Specification Alignment:</h3><ul><li style='margin-bottom: 15px;'>Presently, JayPlus is a well-defined system with clear styles, models, folder structures, and integrated modules. Now, if I were to draft a specification document, the final output would mirror it almost precisely.</li><li style='margin-bottom: 15px;'>However, these documents aren't a one-size-fits-all solution. For a nimble team, say in a fledgling startup, crafting detailed specs for every bug fix could be overkill. Yet, they become indispensable when laying the foundation for new implementations, like analytics. They serve as a proactive measure against accumulating tech debt and offer a sandbox to test ideas without immediate execution.</li></ul><h3>The Goldmine in Application Rewrites:</h3><ul><li style='margin-bottom: 15px;'>When you're rewriting an app, you're not venturing into the unknown. Armed with frontend designs or even Figma prototypes, specification documents can become your North Star. They help crystallize the visualization of elements ranging from the DOM tree to intricate state management.</li><li style='margin-bottom: 15px;'>As for the backend, with the groundwork of JayPlus behind me, I had a bird's-eye view of all required endpoints. This clarity empowered me to strategically lay out handlers, plot integration points, and ponder over system-level architectural considerations.</li></ul><h3>In Conclusion:</h3><p>Specification documents are a potent tool, but they're not infallible. If your journey deviates from the laid-out path, it's not a sign of their failure or yours. These documents are there to navigate, not to shackle. And at times, they might inadvertently lead you astray. This is especially pronounced when your architectural roadmap and style are still in flux. So, use them wisely, but always be ready to embrace the unexpected twists they might unveil.</p></article>",
        "created_at": "2023-10-03T12:00:00Z"
    }
]
